name: 'Telemetry summarize'
description: |
  Consumes job info, parses into spans, and pushes spans.
inputs:
  cert_concat:
    description: Concatenation of certs (CA;Client;ClientKey)

runs:
  using: 'composite'
  steps:
    - uses: ./shared-actions/telemetry-impls/ensure-otel-cli-available
    # Writes JSON file that jobs below consume
    - uses: ./shared-actions/telemetry-impls/github-actions-job-info
      id: github-job-info
      with:
        all_jobs: true
    - name: Upload job JSON file if debugging
      uses: actions/upload-artifact@v4
      if: runner.debug == '1'
      with:
        name: telemetry-tools-all_jobs.json
        path: all_jobs.json
    - uses: ./shared-actions/telemetry-impls/sanity-checks
    # This downloads ALL of the files that we have collected from each job.
    - uses: actions/download-artifact@v4
      with:
        path: attributes_files

    - shell: bash
      run: |
        set -e

        TOP_LEVEL_TRACEPARENT=${TRACEPARENT}
        # Base64 encoding is to avoid issues with spaces/newlines/parens/whatever funny business
        for job_row in $(jq -r '.[] | @base64' all_jobs.json); do

          job_name="$(echo ${job_row} | base64 --decode | jq -r ".name")"
          job_traceparent="$(./shared-actions/telemetry-impls/traceparent.sh "${job_name}")"

          job_id="$(echo ${job_row} | base64 --decode | jq -r ".id")"
          attribute_file=$(pwd)/attributes_files/telemetry-tools-attrs-${job_id}/attrs-${job_id}

          # The reporting of the completion time is earlier than the actual last step's completion.
          # We compensate for that by picking up the last known completion time of any step.
          last_timestamp=$(date +'%s')

          for step_row in $(echo "${job_row}" | base64 --decode | jq -r '.steps[] | @base64'); do
              step_name="$(echo ${step_row} | base64 --decode | jq -r ".name")"
              conclusion="$(echo ${step_row} | base64 --decode | jq -r ".conclusion")"

              step_traceparent="$(./shared-actions/telemetry-impls/traceparent.sh "${job_name}" "$step_name")";

              timestamp_as_date=$last_timestamp
              case $timestamp_as_date in
                  ''|*[!0-9]*) echo "Date is not an integer" ;;
                  *) timestamp_as_date="$(date -d @${last_timestamp} --rfc-3339=ns | sed "s/ /T/g" | sed "s/+00:00/Z/g")" ;;
              esac

              otel span "$step_name" \
                  --attribute-file=${attribute_file}
                  --traceparent=${job_traceparent}
                  --trace-id="$(cut -d'-' -f2 <<<"$job_traceparent")" \
                  --span-id="$(cut -d'-' -f3 <<<"$step_traceparent")" \
                  --start="$(echo ${step_row} | base64 --decode | jq -r ".started_at // \"${timestamp_as_date}\"")" \
                  --end="$(echo ${step_row} | base64 --decode | jq -r ".completed_at // \"${timestamp_as_date}\"")" \

              # Compare timestamps; keep the latest one
              step_end_timestamp="$(echo ${step_row} | base64 --decode | jq -r ".completed_at")";
              if [ "$step_end_timestamp" != "null" ]; then
                step_end_timestamp=$(date -d "$step_end_timestamp" +'%s');
                if [ ${step_end_timestamp} -ge ${last_timestamp} ]; then
                  last_timestamp=${step_end_timestamp};
                fi
              fi
          done

          echo "Final timestamp is ${last_timestamp}"
          case $last_timestamp in
              ''|*[!0-9]*) echo "Date is not an integer" ;;
              *) last_timestamp="$(date -d @${last_timestamp} --rfc-3339=ns | sed "s/ /T/g" | sed "s/+00:00/Z/g")" ;;
          esac

          if [ "$status_description" != "" ] && [ "$status_description" != "null" ]; then
            status_description="--status-description ${status_description}"
          else
            status_description=
          fi

          # unset this so that the parent does not automatically get picked up
          if [ "${TOP_LEVEL_TRACEPARENT}" = "${job_traceparent}" ]; then
            otel span "workflow root" \
                  --attribute-file=${attribute_file}
                  --trace-id "$(cut -d'-' -f2 <<<"$job_traceparent")" \
                  --span-id "$(cut -d'-' -f3 <<<"$job_traceparent")" \
                  --start "${START_TIME}" \
                  --end "${last_timestamp}";
          else
            otel span "Start delay time" \
                  --attribute-file=${attribute_file}
                  --traceparent=${job_traceparent}
                  --trace-id "$(cut -d'-' -f2 <<<"$job_traceparent")" \
                  --span-id "$(cut -d'-' -f3 <<<"$job_traceparent")" \
                  --start "$(jq -r '.created_at // "now"' job_info.json)" \
                  --end "$(jq -r '.started_at // "now"' job_info.json)" \

            otel span "child workflow root" \
                  --attribute-file=${attribute_file}
                  --force-trace-id "$(cut -d'-' -f2 <<<"$job_traceparent")" \
                  --force-span-id "$(cut -d'-' -f3 <<<"$job_traceparent")" \
                  --traceparent ${TOP_LEVEL_TRACEPARENT} \
                  --start "$(jq -r '.created_at // "now"' job_info.json)" \
                  --end "${last_timestamp}";
          fi
        done
    - uses: actions/github-script@v7
      id: clean-up-files
      if: runner.debug != ''
      with:
        retries: 3
        script: |
          get_artifacts = async ({github, context, process}) => {
            const opts = github.rest.actions.listWorkflowRunArtifacts.endpoint.merge(
                {
                    attempt_number: runAttempt,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: context.runId,
                    per_page: 100
                });
            const jobs = await github.paginate(opts);
            return jobs;
          };

          var artifacts = undefined;
          var retryCount = 0;
          maxRetries = 5;
          initialDelay = 2000;
          while (artifacts === undefined) {
            jobs = await get_job({github, context, process});
            if (artifacts === undefined && retryCount < maxRetries) {
              retryCount++;
              await new Promise(res => setTimeout(res, initialDelay * Math.pow(2, retryCount - 1)));
            } else {
              break;
            }
          }

          for (const artifact in artifacts.artifacts) {
            if (artifact.name.startsWith('telemetry-tools-')) {
              octokit.rest.actions.deleteArtifact({
                context.repo.owner,
                context.repo.repo,
                artifact.id,
              });
            }
          }
